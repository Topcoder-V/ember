# åå‘ä¼ æ’­ç®—æ³•Back Propagation Algorithm

import math
import numpy as np


# ä¸‹æ ‡0å‡ä¸ç”¨
# è¾“å…¥å±‚
X = [[0, 0, 0],
     [0, 0, 1],
     [0, 1, 0],
     [0, 1, 1]
    ]

# è¾“å‡ºå±‚
Y = [[0, 0, 0],
     [0, 1, 1],
     [0, 1, 1],
     [0, 0, 0]
    ]

# ç¬¬ä¸€å±‚
w1 = [[0, 0 ,0],
      [0, 1 ,2],
      [0, 3, 4]
     ]
z1 = [0, 1, 1]
a1 = [0, 1, 1]
e1 = [0, 1, 1]

# ç¬¬äºŒå±‚
w2 = [[0, 0 ,0],
      [0 ,1 ,2],
      [0, 3, 4]
     ]
z2 = [0, 1, 1]
a2 = [0, 1, 1]
e2 = [0, 1, 1]

# ç¬¬ä¸‰å±‚
w3 = [[0, 0 ,0],
      [0 ,1 ,2],
      [0, 3, 4]
     ]
z3 = [0, 1, 1]
y = a3 = [0, 1, 1]
e3 = [0, 1, 1]

# Sigmoidå‡½æ•°åŠå…¶å¯¼æ•°
def sigmoid(x):
    return 1 / (1 + np.exp(-x))

# def sigmoid(x):
#     return 1 / (1 + math.exp(-x))

def d_sigmoid(x):
    return x * (1 - x)

# å­¦ä¹ ç‡
yita = 0.4

# è®­ç»ƒè½®æ•°
epochs = 50000
for p in range(epochs):
    C = 0
    for k in range(len(X)):
        y_hat  = Y[k]
        a0 = x = X[k]

        # ç¬¬ä¸€å±‚
        # æ³¨æ„ï¼šè¿™é‡Œå’Œç†è®ºè®²è§£æ—¶çš„wå‘½åæœ‰æ‰€åŒºåˆ«ï¼Œä¾‹å¦‚w12ä¸ºä»x2åˆ°x1çš„æƒé‡ï¼Œä½†åœ¨ä»£ç ä¸­å®šä¹‰ä¸ºw12ä¸ºä»x1åˆ°x2çš„æƒé‡
        z1[1] = x[1]*w1[1][1] + x[2]*w1[2][1]
        z1[2] = x[1]*w1[1][2] + x[2]*w1[2][2]

        a1[1] = sigmoid(z1[1])
        a1[2] = sigmoid(z1[2])

        # ç¬¬äºŒå±‚
        z2[1] = a1[1]*w2[1][1] + a1[2]*w2[2][1]
        z2[2] = a1[1]*w2[1][2] + a1[2]*w2[2][2]

        a2[1] = sigmoid(z2[1])
        a2[2] = sigmoid(z2[2])

        # ç¬¬ä¸‰å±‚
        z3[1] = a2[1]*w3[1][1] + a2[2]*w3[2][1]
        z3[2] = a2[1]*w3[1][2] + a2[2]*w3[2][2]

        a3[1] = sigmoid(z3[1])
        a3[2] = sigmoid(z3[2])

        # ** æ˜¯æŒ‡æ•°è¿ç®—ç¬¦ï¼Œè¡¨ç¤ºå¯¹æ“ä½œç¬¦å·¦è¾¹çš„æ•°å€¼è¿›è¡Œæ“ä½œç¬¦å³è¾¹æ•°å€¼çš„å¹‚è¿ç®—ã€‚æ‰€ä»¥ï¼Œ**2 è¡¨ç¤ºå¯¹å·¦è¾¹çš„æ•°å€¼è¿›è¡Œå¹³æ–¹è¿ç®—
        C += (a3[1] - y_hat[1])**2 + (a3[2] - y_hat[2])**2

        # åå‘ä¼ æ’­ åˆ©ç”¨ç¬¬äºŒä¸ªé’»çŸ³é€šé¡¹å…¬å¼
        # ç¬¬ä¸‰å±‚
        e3[1] = 2*(a3[1] - y_hat[1]) # ğœ•C/ğœ•a3_1
        e3[2] = 2*(a3[2] - y_hat[2]) # ğœ•C/ğœ•a3_2
        # ç¬¬äºŒå±‚
        # d_sigmoid æ˜¯æŒ‡ Sigmoid å‡½æ•°çš„å¯¼æ•°. Sigmoid å‡½æ•°çš„å¯¼æ•°æ˜¯å…¶å€¼çš„å‡½æ•°
        e2[1] = e3[1] * d_sigmoid(a3[1])*w3[1][1] + e3[2] * d_sigmoid(a3[2])*w3[1][2]
        e2[2] = e3[1] * d_sigmoid(a3[1])*w3[2][1] + e3[2] * d_sigmoid(a3[2])*w3[2][2]
        # ç¬¬ä¸€å±‚
        e1[1] = e2[1] * d_sigmoid(a2[1])*w2[1][1] + e2[2] * d_sigmoid(a2[2])*w2[1][2]
        e1[2] = e2[1] * d_sigmoid(a2[1])*w2[2][1] + e2[2] * d_sigmoid(a2[2])*w2[2][2]

        # æ›´æ–°æƒé‡ æ¢¯åº¦ä¸‹é™
        # æ›´æ–°æƒé‡ æ¢¯åº¦ä¸‹é™
        for i in range(1, 3):
            for j in range(1, 3):
                w1[i][j] -= yita * (e1[j]*d_sigmoid(a1[j])*a0[i]) # ğœ•C / ğœ•w1_i_j
                w2[i][j] -= yita * (e2[j]*d_sigmoid(a2[j])*a1[i]) # ğœ•C / ğœ•w2_i_j
                w3[i][j] -= yita * (e3[j]*d_sigmoid(a3[j])*a2[i]) # ğœ•C / ğœ•w3_i_j

    if p % 5000 == 0:
        print('Total Cost: ', C)

# åº”ç”¨ç¥ç»ç½‘ç»œ
x[1] = 0
x[2] = 1

z1[1] = x[1]*w1[1][1] + x[2]*w1[2][1]
z1[2] = x[1]*w1[1][2] + x[2]*w1[2][2]

a1[1] = sigmoid(z1[1])
a1[2] = sigmoid(z1[2])


z2[1] = a1[1]*w2[1][1] + a1[2]*w2[2][1]
z2[2] = a1[1]*w2[1][2] + a1[2]*w2[2][2]

a2[1] = sigmoid(z2[1])
a2[2] = sigmoid(z2[2])

z3[1] = a2[1]*w3[1][1] + a2[2]*w3[2][1]
z3[2] = a2[1]*w3[1][2] + a2[2]*w3[2][2]

a3[1] = sigmoid(z3[1])
a3[2] = sigmoid(z3[2])


print(a3[1], ",", a3[2])
C = (a3[1] - 1)**2 + (a3[2] - 1)**2 # ä¸ºä»€ä¹ˆè¿™é‡Œ-1å‘¢ï¼Ÿ
print('Loss = ', C)
